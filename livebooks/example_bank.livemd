# Bedrock Example

```elixir
Mix.install([
  {:bedrock, git: "https://github.com/jallum/bedrock.git", branch: "develop"},
  {:kino, "~> 0.16.0"}
])
```

## Setup

```elixir
require Logger
working_dir = Path.join(System.tmp_dir!(), "bedrock_#{:rand.uniform(99999)}")
Logger.info("Working directory: #{working_dir}")
File.mkdir_p!(working_dir)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Example.Cluster do
  use Bedrock.Cluster,
    otp_app: :example_app,
    name: "test",
    config: [
      capabilities: [:coordination, :log, :storage],
      trace: [:coordinator, :recovery],
      coordinator: [
        path: working_dir
      ],
      storage: [
        path: working_dir
      ],
      log: [
        path: working_dir
      ]
    ]
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.start_child!({Example.Cluster, []})
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Example.Cluster.transaction_system_layout!()
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Example.Repo do
  use Bedrock.Repo,
    cluster: Example.Cluster
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Example.Bank do
  alias Example.Repo
  alias Bedrock.Subspace

  # Define subspaces for different data categories
  @accounts_space Subspace.new({"accounts"})
  @transactions_space Subspace.new({"transactions"})
  @metadata_space Subspace.new({"metadata"})

  @doc """
  Create an account with balance, optional metadata, and transaction history.

  Demonstrates:
  - Using subspaces for organized key structure
  - Atomic writes across multiple subspaces
  - Transaction rollback on exceptions
  """
  def create_account(tx, account, balance, opts \\ []) when is_binary(account) and is_integer(balance) do
    account_type = Keyword.get(opts, :type, "checking")

    tx
    |> fetch_balance(account)
    |> case do
      {:error, :account_not_found} ->
        timestamp = System.system_time(:second)

        # Write to multiple subspaces atomically
        set_balance(tx, account, balance)
        set_account_metadata(tx, account, %{
          type: account_type,
          created_at: timestamp,
          status: "active"
        })
        record_transaction(tx, account, balance, "account_creation", timestamp)

        {:ok, balance}
      {:ok, existing_balance} ->
        if opts[:on_exists] == :raise do
          raise "Account #{account} already exists"
        end
        {:ok, existing_balance}
    end
  end

  @doc """
  Move money between accounts with full transaction history.

  Demonstrates:
  - Multi-subspace atomic operations
  - Transaction history tracking
  - Repeatable reads optimization
  """
  def move_money(tx, amount, from_account, to_account) when is_integer(amount) and amount > 0 do
    timestamp = System.system_time(:millisecond)

    with :ok <- check_sufficient_balance_for_transfer(tx, from_account, amount),
         {:ok, new_balance1} <- adjust_balance(tx, from_account, -amount),
         {:ok, new_balance2} <- adjust_balance(tx, to_account, amount) do

      # Record transaction history for both accounts
      record_transaction(tx, from_account, -amount, "transfer_out", timestamp, %{to: to_account})
      record_transaction(tx, to_account, amount, "transfer_in", timestamp, %{from: from_account})

      {:ok, new_balance1, new_balance2}
    end
  end

  @doc """
  List all accounts with their balances using subspace range operations.

  Demonstrates:
  - Subspace.range/1 for efficient key range scanning
  - Subspace.unpack/2 for clean key extraction
  """
  def list_accounts(tx, opts \\ []) do
    limit = Keyword.get(opts, :limit, 1000)
    {start_key, end_key} = Subspace.range(@accounts_space)

    accounts =
      tx
      |> Repo.get_range(start_key, end_key, limit: limit)
      |> Enum.map(fn {key, balance} ->
        {account} = Subspace.unpack(@accounts_space, key)
        {account, :binary.decode_unsigned(balance)}
      end)

    {:ok, accounts}
  end

  @doc """
  Get transaction history for an account using subspace ranges.

  Demonstrates:
  - Nested subspace operations
  - Efficient range queries for audit trails
  """
  def get_transaction_history(tx, account, opts \\ []) do
    limit = Keyword.get(opts, :limit, 100)

    # Create range for all transactions for this account
    account_tx_space = transaction_space(account)
    {start_key, end_key} = Subspace.range(account_tx_space)

    transactions =
      tx
      |> Repo.get_range(start_key, end_key, limit: limit)
      |> Stream.map(fn {key, tx_data} ->
        {timestamp} = Subspace.unpack(account_tx_space, key)

        tx_data
        |> :erlang.binary_to_term()
        |> Map.put(:timestamp, timestamp)
      end)

    {:ok, transactions}
  end

  @doc """
  Get account metadata (creation time, type, status).

  Demonstrates:
  - Metadata organization in separate subspace
  - Structured data retrieval
  """
  def get_account_info(tx, account) do
    with {:ok, balance} <- fetch_balance(tx, account),
         {:ok, metadata} <- fetch_account_metadata(tx, account) do
      {:ok, Map.put(metadata, :balance, balance)}
    else
      {:error, :not_found} -> {:error, :account_not_found}
      error -> error
    end
  end

  @doc """
  List accounts by type using nested subspaces.

  Demonstrates:
  - Subspace filtering and organization
  - Efficient queries by account attributes
  """
  def list_accounts_by_type(tx, account_type, opts \\ []) do
    with {:ok, all_accounts} <- list_accounts(tx, opts) do
      matching_accounts =
        all_accounts
        |> Enum.filter(fn {account, _balance} ->
          case get_account_info(tx, account) do
            {:ok, %{type: ^account_type}} -> true
            _ -> false
          end
        end)

      {:ok, matching_accounts}
    end
  end

  def account_exists?(tx, account) do
    case fetch_balance(tx, account) do
      {:ok, _} -> true
      _ -> false
    end
  end

  @doc """
  Get summary statistics with enhanced metadata.
  """
  def account_summary(tx, opts \\ []) do
    case list_accounts(tx, opts) do
      {:ok, accounts} ->
        total_balance = accounts |> Stream.map(fn {_, balance} -> balance end) |> Enum.sum()
        account_count = length(accounts)

        # Get account type breakdown
        type_breakdown =
          accounts
          |> Stream.map(fn {account, balance} ->
            case get_account_info(tx, account) do
              {:ok, %{type: type}} -> {type, balance}
              _ -> {"unknown", balance}
            end
          end)
          |> Enum.group_by(fn {type, _} -> type end, fn {_, balance} -> balance end)
          |> Enum.map(fn {type, balances} -> {type, %{count: length(balances), total: Enum.sum(balances)}} end)
          |> Enum.into(%{})

        avg_balance = if account_count > 0, do: total_balance / account_count, else: 0.0

        {:ok, %{
          total_accounts: account_count,
          total_balance: total_balance,
          average_balance: Float.round(avg_balance, 2),
          by_type: type_breakdown
        }}
    end
  end

  # Private helper functions

  defp transaction_space(account), do: Subspace.create(@transactions_space, {account})

  defp balance_key(account), do: Subspace.pack(@accounts_space, {account})
  defp metadata_key(account), do: Subspace.pack(@metadata_space, {account})
  defp transaction_key(account, timestamp), do: account |> transaction_space() |> Subspace.pack({timestamp})

  defp check_sufficient_balance_for_transfer(tx, account, amount) do
    with {:ok, balance} <- fetch_balance(tx, account) do
      if can_withdraw?(amount, balance) do
        :ok
      else
        {:error, :insufficient_funds}
      end
    end
  end

  defp fetch_balance(tx, account) do
    case Repo.get(tx, balance_key(account)) do
      nil -> {:error, :account_not_found}
      balance -> {:ok, :binary.decode_unsigned(balance)}
    end
  end

  defp adjust_balance(tx, account, amount) do
    with {:ok, balance} <- fetch_balance(tx, account) do
      new_balance = balance + amount
      set_balance(tx, account, new_balance
      )
      {:ok, new_balance}
    end
  end

  defp set_balance(tx, account, amount) when amount >= 0,
    do: Repo.put(tx, balance_key(account), :binary.encode_unsigned(amount))

  defp set_account_metadata(tx, account, %{} = metadata),
    do: Repo.put(tx, metadata_key(account), :erlang.term_to_binary(metadata))

  defp fetch_account_metadata(tx, account) do
    case Repo.get(tx, metadata_key(account)) do
      nil -> {:error, :no_metadata}
      metadata -> {:ok, :erlang.binary_to_term(metadata)}
    end
  end

  defp record_transaction(tx, account, amount, type, timestamp, extra \\ %{}) do
    tx_data = Map.merge(%{
      amount: amount,
      type: type,
      account: account
    }, extra)
    Repo.put(tx, transaction_key(account, timestamp), :erlang.term_to_binary(tx_data))
  end

  defp can_withdraw?(amount, balance), do: balance >= amount
end

alias Example.Bank
alias Example.Repo
```

```elixir
# Create accounts with different types using subspace organization
Repo.transact(fn tx ->
  {:ok, jim_balance} = Bank.create_account(tx, "jim", 1000, type: "checking")
  {:ok, tina_balance} = Bank.create_account(tx, "tina", 2500, type: "savings")
  {:ok, alice_balance} = Bank.create_account(tx, "alice", 750, type: "checking")
  {:ok, bob_balance} = Bank.create_account(tx, "bob", 5000, type: "business")

  IO.puts("=== Created Accounts ===")
  IO.puts("Jim (checking): $#{jim_balance}")
  IO.puts("Tina (savings): $#{tina_balance}")
  IO.puts("Alice (checking): $#{alice_balance}")
  IO.puts("Bob (business): $#{bob_balance}")

  {:ok, %{jim: jim_balance, tina: tina_balance, alice: alice_balance, bob: bob_balance}}
end)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Transfer money - this will create transaction history in the transactions subspace
Repo.transact(fn tx ->
  case Bank.move_money(tx, 250, "tina", "jim") do
    {:ok, tina_balance, jim_balance} ->
      IO.puts("Transfer successful!")
      IO.puts("Tina's new balance: $#{tina_balance}")
      IO.puts("Jim's new balance: $#{jim_balance}")
      {:ok, %{tina: tina_balance, jim: jim_balance}}
    {:error, reason} ->
      IO.puts("Transfer failed: #{reason}")
      {:error, reason}
  end
end)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Demonstrate subspace-based account information retrieval
Repo.transact(fn tx ->
  IO.puts("=== Account Information ===")

  ["jim", "tina", "alice", "bob"]
  |> Enum.each(fn account ->
    case Bank.get_account_info(tx, account) do
      {:ok, info} ->
        created_date = DateTime.from_unix!(info.created_at, :second) |> DateTime.to_date()
        IO.puts("#{String.capitalize(account)}: $#{info.balance} (#{info.type}, created #{created_date})")
      {:error, _} ->
        IO.puts("#{String.capitalize(account)}: Account not found")
    end
  end)

  :ok
end)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# List all accounts using subspace range operations
Repo.transact(fn tx ->
  case Bank.list_accounts(tx) do
    {:ok, accounts} ->
      IO.puts("=== All Accounts (Subspace Range Query) ===")
      Enum.each(accounts, fn {account, balance} ->
        IO.puts("  #{account}: $#{balance}")
      end)
      accounts
    {:error, reason} ->
      IO.puts("Error listing accounts: #{inspect(reason)}")
  end
end)
```

```elixir
# Get transaction history for an account - demonstrates transaction subspace
Repo.transact(fn tx ->
  IO.puts("=== Transaction History for Jim ===")
  case Bank.get_transaction_history(tx, "jim") do
    {:ok, transactions} ->
      Enum.each(transactions, fn tx_data ->
        date = DateTime.from_unix!(tx_data.timestamp, :millisecond) |> DateTime.to_string()
        amount_str = if tx_data.amount > 0, do: "+$#{tx_data.amount}", else: "$#{tx_data.amount}"

        extra_info = case tx_data do
          %{from: from_account} -> " (from #{from_account})"
          %{to: to_account} -> " (to #{to_account})"
          _ -> ""
        end

        IO.puts("  #{date}: #{amount_str} - #{tx_data.type}#{extra_info}")
      end)
      transactions
    {:error, reason} ->
      IO.puts("Error getting transaction history: #{reason}")
  end
end)
```

```elixir
# List accounts by type - demonstrates metadata subspace usage
Repo.transact(fn tx ->
  IO.puts("=== Checking Accounts ===")
  case Bank.list_accounts_by_type(tx, "checking") do
    {:ok, checking_accounts} ->
      Enum.each(checking_accounts, fn {account, balance} ->
        IO.puts("  #{account}: $#{balance}")
      end)

      IO.puts("\n=== Business Accounts ===")
      {:ok, business_accounts} = Bank.list_accounts_by_type(tx, "business")
      Enum.each(business_accounts, fn {account, balance} ->
        IO.puts("  #{account}: $#{balance}")
      end)

      {:ok, %{checking: checking_accounts, business: business_accounts}}
    {:error, reason} ->
      IO.puts("Error filtering accounts: #{reason}")
  end
end)
```

```elixir
# Enhanced bank summary with account type breakdown
Repo.transact(fn tx ->
  case Bank.account_summary(tx) do
    {:ok, summary} ->
      IO.puts("=== Enhanced Bank Summary ===")
      IO.puts("Total Accounts: #{summary.total_accounts}")
      IO.puts("Total Balance: $#{summary.total_balance}")
      IO.puts("Average Balance: $#{summary.average_balance}")

      IO.puts("\n=== By Account Type ===")
      Enum.each(summary.by_type, fn {type, stats} ->
        IO.puts("  #{String.capitalize(type)}: #{stats.count} accounts, $#{stats.total} total")
      end)

      summary
    {:error, reason} ->
      IO.puts("Error getting summary: #{inspect(reason)}")
  end
end)
```

```elixir
# Demonstrate atomic multi-subspace operations with rollback
Repo.transact(fn tx ->
  IO.puts("=== Testing Multi-Subspace Rollback ===")

  # This transaction will create data across all three subspaces, then roll back
  Bank.create_account(tx, "temp_user", 1000, type: "temporary")
  Bank.move_money(tx, 100, "jim", "temp_user")

  # Show that the changes are visible within the transaction
  {:ok, info} = Bank.get_account_info(tx, "temp_user")
  {:ok, history} = Bank.get_transaction_history(tx, "temp_user")

  IO.puts("Temp account created with balance: $#{info.balance}")
  IO.puts("Transaction history entries: #{history |> Enum.count()}")

  # Rollback by returning error
  {:error, "Intentionally rolled back to demonstrate atomicity"}
end)
```

```elixir
# Verify rollback worked - temp_user should not exist
Repo.transact(fn tx ->
  case Bank.get_account_info(tx, "temp_user") do
    {:ok, _info} ->
      IO.puts("❌ Rollback failed - temp_user still exists")
      :ok
    {:error, :account_not_found} ->
      IO.puts("✅ Rollback successful - temp_user was properly removed")

      # Also verify Jim's balance wasn't affected
      {:ok, jim_info} = Bank.get_account_info(tx, "jim")
      IO.puts("Jim's balance unchanged: $#{jim_info.balance}")
      :ok
  end
end)
```
