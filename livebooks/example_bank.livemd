# Bedrock Example

```elixir
Mix.install([
#  {:bedrock, git: "https://github.com/jallum/bedrock.git", branch: "develop"},
  {:bedrock, path: "/Users/j5n/Workspace/bedrock"},
  {:kino, "~> 0.16.0"}
])
```

## Setup

```elixir
require Logger
working_dir = Path.join(System.tmp_dir!(), "bedrock_#{:rand.uniform(99999)}")
Logger.info("Working directory: #{working_dir}")
File.mkdir_p!(working_dir)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Example.Cluster do
  use Bedrock.Cluster,
    otp_app: :example_app,
    name: "test",
    config: [
      capabilities: [:coordination, :log, :storage],
      trace: [:coordinator, :recovery],
      coordinator: [
        path: working_dir
      ],
      storage: [
        path: working_dir
      ],
      log: [
        path: working_dir
      ]
    ]
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.start_child!({Example.Cluster, []})
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Example.Cluster.transaction_system_layout!()
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Example.Repo do
  use Bedrock.Repo,
    cluster: Example.Cluster,
    key_codecs: [
      default: Bedrock.KeyCodec.TupleKeyCodec
    ],
    value_codecs: [
      default: Bedrock.ValueCodec.BertValueCodec
    ]
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Example.Bank do
  alias Example.Repo

  @doc """
  Create an account, given an account number and a balance. Optionally, raise an 
  exception if the account already exists.

  Demonstrates:
  - Transactions that produce no writes will not generate a commit.
  - exceptions will properly rollback the transaction.
  """
  def create_account(tx, account, balance, opts \\ []) when is_binary(account) and is_integer(balance) do
    tx
    |> fetch_balance(account)
    |> case do
      {:error, :account_not_found} ->
        set_balance(tx, account, balance)
        {:ok, balance}
      {:ok, existing_balance} ->
        if opts[:on_exists] == :raise do
          raise "Account #{account} already exists"
        end
        {:ok, existing_balance}
    end
  end

  @doc """
  Move an amount of money from one account to another.

  Demonstrates:
  - Repeatable point reads over the same keys do not cause multiple storage reads.
  - Errors returned from a transaction function will automatically roll back the transaction.
  """
  def move_money(tx, amount, account1, account2) when is_integer(amount) and amount > 0 do
    with :ok <- check_sufficient_balance_for_transfer(tx, account1, amount),
         {:ok, new_balance1} <- adjust_balance(tx, account1, -amount),
         {:ok, new_balance2} <- adjust_balance(tx, account2, amount) do
      {:ok, new_balance1, new_balance2}
    end
  end

  def account_exists?(tx, account) do
    case fetch_balance(tx, account) do
      {:ok, _} -> true
      _ -> false
    end
  end

  @doc """
  List all accounts and their balances.

  Demonstrates:
  - Range reads using the new range_fetch functionality
  - Efficient scanning of all accounts with tuple key prefixes
  - Optional limit parameter for large account sets
  """
  def list_accounts(tx, opts \\ []) do
    limit = Keyword.get(opts, :limit, 1000)
    
    # Use range_stream to get all keys starting with {"balances", ...}
    # The range goes from {"balances"} to {"balances\0"} which covers all balance keys
    accounts = 
      tx 
      |> Repo.range_stream({"balances"}, {"balances\0"}, limit: limit)
      |> Enum.map(fn {{"balances", account}, balance} -> {account, balance} end)
    
    {:ok, accounts}
  end

  @doc """
  Get summary statistics for all accounts.

  Demonstrates:
  - Using list_accounts as a building block for analytics
  - Processing range query results efficiently
  """
  def account_summary(tx, opts \\ []) do
    case list_accounts(tx, opts) do
      {:ok, accounts} ->
        total_balance = accounts |> Enum.map(fn {_, balance} -> balance end) |> Enum.sum()
        account_count = length(accounts)
        
        avg_balance = if account_count > 0, do: total_balance / account_count, else: 0.0
        
        {:ok, %{
          total_accounts: account_count,
          total_balance: total_balance,
          average_balance: Float.round(avg_balance, 2),
          accounts: accounts
        }}
    end
  end

  defp check_sufficient_balance_for_transfer(tx, account, amount) do
    with {:ok, balance} <- fetch_balance(tx, account) do
      if can_withdraw?(amount, balance) do
        :ok
      else
        {:error, :insufficient_funds}
      end
    end
  end

  defp fetch_balance(tx, account) do
    case Repo.fetch(tx, key_for_account_balance(account)) do
      {:ok, balance} -> {:ok, balance}
      {:error, :not_found} -> {:error, :account_not_found}
    end
  end

  defp adjust_balance(tx, account, amount) do
    with {:ok, balance} <- fetch_balance(tx, account) do
      new_balance = balance + amount
      set_balance(tx, account, new_balance)
      {:ok, new_balance}
    end
  end

  defp set_balance(tx, account, amount), 
    do: Repo.put(tx, key_for_account_balance(account), amount)

  defp can_withdraw?(amount, balance), do: balance >= amount

  defp key_for_account_balance(account), do: {"balances", account}
end

alias Example.Bank
alias Example.Repo
```

```elixir
Repo.transaction(fn tx ->
  Bank.create_account(tx, "jim", 100)
end)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Repo.transaction(fn tx ->
  Bank.create_account(tx, "tina", 500, on_exists: :raise)  
end)
```

```elixir
Repo.transaction(fn tx ->
  Bank.move_money(tx, 84, "tina", "jim")  
end)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Let's create a few more accounts to demonstrate list_accounts
Repo.transaction(fn tx ->
  {:ok, a} = Bank.create_account(tx, "alice", 250)
  {:ok, b} = Bank.create_account(tx, "bob", 750) 
  {:ok, c} = Bank.create_account(tx, "charlie", 100)
  
  {:ok, %{alice: a, bob: b, charlie: c}}
end)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# List all accounts using the new range_fetch functionality
Repo.transaction(fn tx ->
  case Bank.list_accounts(tx) do
    {:ok, accounts} -> 
      IO.puts("All accounts:")
      Enum.each(accounts, fn {account, balance} -> 
        IO.puts("  #{account}: $#{balance}")
      end)
      accounts
    {:error, reason} -> 
      IO.puts("Error listing accounts: #{inspect(reason)}")
  end  
end)

```

```elixir
# List accounts with a limit
Repo.transaction(fn tx -> 
  case Bank.list_accounts(tx, limit: 3) do
    {:ok, accounts} -> 
      IO.puts("First 3 accounts:")
      Enum.each(accounts, fn {account, balance} -> 
        IO.puts("  #{account}: $#{balance}")
      end)
      accounts
    {:error, reason} -> 
      IO.puts("Error listing accounts: #{inspect(reason)}")
  end  
end)

```

```elixir
# Demonstrate that list_accounts sees uncommitted changes within the same transaction
Repo.transaction(fn tx ->
  # Create a temporary account within this transaction
  Repo.put(tx, {"balances", "temp_account"}, 999)
  
  # List accounts - should include the temporary account
  {:ok, accounts} = Bank.list_accounts(tx)
  
  IO.puts("Accounts visible within transaction:")
  Enum.each(accounts, fn {account, balance} -> 
    IO.puts("  #{account}: $#{balance}")
  end)
  
  # This transaction will be rolled back since we don't return :ok
  {:rollback, accounts}
end)
```

```elixir
# Verify the temporary account was rolled back
Repo.transaction(fn tx ->
  Bank.list_accounts(tx)  
end)
```

```elixir
Repo.transaction(fn tx ->
  # Get account summary statistics
  case Bank.account_summary(tx) do
    {:ok, summary} ->
      IO.puts("=== Bank Summary ===")
      IO.puts("Total Accounts: #{summary.total_accounts}")
      IO.puts("Total Balance: $#{summary.total_balance}")
      IO.puts("Average Balance: $#{summary.average_balance}")
      summary
    {:error, reason} ->
      IO.puts("Error getting summary: #{inspect(reason)}")
  end  
end)

```
